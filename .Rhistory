y = samples_df_order$N_IS1,
group = "ICESat"
)
# Combine the data frames
combined_df <- rbind(df1, df2)
# Plot the values using ggplot
ggplot(combined_df , aes(x , y =y , fill = group)) +
geom_bar(stat = "identity", position = "identity") +
xlab("Grid index") +
ylab("Number of GEDI/IS1 shots per grid") +
coord_cartesian(clip = "off", ylim= c(0,1000))
View(sample_counts)
# Plot the values using ggplot
ggplot(combined_df , aes(x , y =y , fill = group)) +
geom_bar(stat = "identity", position = "identity") +
xlab("Grid index") +
ylab("Number of GEDI/IS1 shots per grid") +
coord_cartesian(clip = "off", ylim= c(0,1000))
samples_df$diff_number  <-  samples_df$N_GEDI - samples_df$N_IS1
ggplot(samples_df , aes(Grid , diff)) +
geom_bar(stat = "identity") +
xlab("Grids number") +
ylab("GEDI - IS1 diff") +
ylim(-10, 10)
## his
ggplot(samples_df , aes(diff )) +
geom_histogram(binwidth = 2, position = "identity", alpha = 0.7) +
xlab("Difference") +
ylab("GEDI/IS1 number")
####
result <- cbind(samples_df$IS1_h,samples_df$GEI_h)
result <- data.frame(result)
colnames(result) <- c('is1_values', 'gedi_rh98')
# Define height class intervals
height_bins <- cut(result$is1_values, breaks = seq(0.5,60.5))
# Group data by height class and calculate mean weight
gedi_median <- aggregate(result$gedi_rh98, by = list(height_class = height_bins), FUN = median)
gedi_mean <- aggregate(result$gedi_rh98, by = list(height_class = height_bins), FUN = mean)
gedi_median_x <- as.character(gedi_median$height_class)
# Load the stringr package
library(stringr)
gedi_median_x <-  str_extract(gedi_median_x, "(?<=\\,).*?(?=\\.)")
gedi_median_x <- as.numeric(gedi_median_x)
# Calculate the number of samples in each class
height_bins <- cut(result$is1_values, breaks = seq(0.5,60.5,2))
result$height_class <- height_bins
sample_counts <- result %>% count(height_class)
x_sample <-  str_extract(sample_counts$height_class, "(?<=\\,).*?(?=\\.)")
sample_counts$x <- as.numeric(x_sample)
df_1 <- data.frame(gedi_median_x, gedi_median$x ) # median
colnames(df_1) <- c('x', 'y')
df_1<- merge(df_1, sample_counts, by = "x", all = TRUE)
df_1['type'] = 'median'
df_2 <- data.frame(gedi_median_x, gedi_mean$x) # mean
colnames(df_2) <- c('x', 'y')
df_2<- merge(df_2, sample_counts, by = "x", all = TRUE)
df_2['type'] = 'mean'
# Combine the data frames
combined_df <- rbind(df_1, df_2)
# Remove NA rows
combined_df <- na.omit(combined_df)
df_1 <- na.omit(df_1 )
p2 <- ggplot(combined_df,aes(x , y , color = type, fill = type)) +
geom_point(aes(shape=type),size =3) +
scale_color_manual(values = c("mean" = "red", "median" = "blue") )+
#scale_fill_manual(values = c("mean" = "orange", "median" = "lightblue") )+
scale_shape_manual(values = c("mean" = 16, "median" = 17))+
theme_bw()+
theme(plot.title = element_text(hjust = 0.5),
panel.grid = element_blank(),
#legend.position = c(0.1, 0.8),
)+
geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed",linewidth = 1 )+
xlim(c(0,42)) +
ylim(c(0,42))+
#geom_smooth(method = "lm", linewidth = 2, fullrange = TRUE, se = TRUE) +
# geom_text( aes(
#                                 label = format(n, big.mark = ",",
#                                 scientific = FALSE)), vjust = -1, size = 5)+
labs(x = "Icesat-1 [m]", y = "GEDI_cal/val_shots [m]", title = "Median of GEDI at 1/8° from ICESat")
p2
p2 <- ggplot(combined_df,aes(x , y , color = type, fill = type)) +
geom_point(aes(shape=type),size =3) +
scale_color_manual(values = c("mean" = "red", "median" = "blue") )+
#scale_fill_manual(values = c("mean" = "orange", "median" = "lightblue") )+
scale_shape_manual(values = c("mean" = 16, "median" = 17))+
theme_bw()+
theme(plot.title = element_text(hjust = 0.5),
panel.grid = element_blank(),
#legend.position = c(0.1, 0.8),
)+
geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed",linewidth = 1 )+
xlim(c(0,32)) +
ylim(c(0,32))+
#geom_smooth(method = "lm", linewidth = 2, fullrange = TRUE, se = TRUE) +
# geom_text( aes(
#                                 label = format(n, big.mark = ",",
#                                 scientific = FALSE)), vjust = -1, size = 5)+
labs(x = "Icesat-1 [m]", y = "GEDI_cal/val_shots [m]", title = "Median of GEDI at 1/8° from ICESat")
p2
p2 <- ggplot(combined_df,aes(x , y , color = type, fill = type)) +
geom_point(aes(shape=type),size =3) +
scale_color_manual(values = c("mean" = "red", "median" = "blue") )+
#scale_fill_manual(values = c("mean" = "orange", "median" = "lightblue") )+
scale_shape_manual(values = c("mean" = 16, "median" = 17))+
theme_bw()+
theme(plot.title = element_text(hjust = 0.5),
panel.grid = element_blank(),
#legend.position = c(0.1, 0.8),
)+
geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed",linewidth = 1 )+
xlim(c(0,30)) +
ylim(c(0,30))+
#geom_smooth(method = "lm", linewidth = 2, fullrange = TRUE, se = TRUE) +
# geom_text( aes(
#                                 label = format(n, big.mark = ",",
#                                 scientific = FALSE)), vjust = -1, size = 5)+
labs(x = "Icesat-1 [m]", y = "GEDI_cal/val_shots [m]", title = "Median of GEDI at 1/8° from ICESat")
p2
is1 <- glas_veg[, c('lon', 'lat', 'ht')]
nrow(is1)
library(sf)
sf_points <- st_as_sf(is1, coords = c("lon", "lat"),  crs = 4326)
buffered_points <- st_buffer(sf_points, dist = 500)
360/0.125
180/0.125
for (i_lon in -180:180:0.125) {
print(i_lon)
}
360/0.125
for (i in 1:2880) {
lon = -180 + i*0.125
print(lon)
}
for (i in 1:2880) {
i=1
lon = -180 + i*0.125
print(lon)
}
for (i in 1:2880) {
lon = -180 + i*0.125
print(lon)
}
360/0.125
for (i in 1:2880-1) {
lon = -180 + i*0.125
print(lon)
}
180/0.125
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (i in 1:1440-1) {
lat = -90 + i*0.125
print(lat)
}
}
52*2/0.125
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (i in 1:832-1) {
lat = -52 + i*0.125
print(lat)
}
}
i=10000
lon = -180 + i*0.125
lat = -52 + i*0.125
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
x_coord
y_coord
i= 1000
lon = -180 + i*0.125
j = 500
lat = -52 + j*0.125
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
x_coord
y_coord
head(is1)
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
filtered_points
head(filtered_points)
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
print(lat)
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
plot(dat_circles)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(buffered_points, bufferName, layer = "icesat")
}
}
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
plot(dat_circles)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(buffered_points, bufferName, layer = "icesat")
}
}
lon = -68
lat = -5
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
filtered_points
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
head( filtered_points )
filtered_points[filtered_points$in_flag > 0, ]
x_coord
y_coord
plot(x_coord, y_coord)
class(is1$lon[1])
class(is1$lat[1])
is1$lat[1]
View(is1)
head(in_flag)
summary(in_flag)
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
summary(in_flag)
x_coord
y_coord
?point.in.polygon
resolution <- 12.5     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
summary(in_flag)
resolution <- 1.25     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
summary(in_flag)
lon = -54.54
lat = -6.16
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
summary(in_flag)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
plot(dat_circles)
dat_circles
dat_circles_union <- st_union(dat_circles)
plot(dat_circles_union)
dat_circles_union
dat_circles_union
dat_circles_union
?st_union
dat_circles_union <- st_union(dat_circles, is_coverage = TRUE)
plot(dat_circles_union)
dat_circles_union
dat_circles_union <- st_union(dat_circles, by_feature = TRUE)
plot(dat_circles_union)
dat_circles_union
dat_circles_union <- st_union(dat_circles)
plot(dat_circles_union)
i
j
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(dat_circles_union, bufferName, layer = "icesat")
library(sf)
install.packages("sf")
library(sf)
install.packages("s2")
library(sf)
install.packages("sf")
library(sf)
load('Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Data/icesat_glas_umd_v1.RData')
is1 <- glas_veg[, c('lon', 'lat', 'ht')]
########### how many 0.125 degree grids ????
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
lon = -54.54
lat = -6.16
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
dat_circles_union <- st_union(dat_circles)
#plot(dat_circles_union)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(dat_circles_union, bufferName, layer = "icesat")
}
}
########################Create a buffer =500 m and save in gpkg format
library(sf)
??point.in.polygon
library(sp)
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
lon = -54.54
lat = -6.16
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
dat_circles_union <- st_union(dat_circles)
#plot(dat_circles_union)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(dat_circles_union, bufferName, layer = "icesat")
}
}
?st_write
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
#lon = -54.54
#lat = -6.16
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
dat_circles_union <- st_union(dat_circles)
#plot(dat_circles_union)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m", '_i_j.gpkg')
st_write(dat_circles_union, bufferName, layer = "icesat", delete_layer = TRUE) # overwrites)
}
}
for (i in 1:2880-1) {
lon = -180 + i*0.125
#print(lon)
for (j in 1:832-1) {
lat = -52 + j*0.125
#lon = -54.54
#lat = -6.16
### for each grid
# Step 1: filter is1 points
###
# Define the center point and resolution
# center <- c(13.3125,49.1875)      # Center coordinates (longitude, latitude)
resolution <- 0.125     # Resolution in degrees
# Calculate the half-length of the square in each dimension
half_length <- resolution / 2
# Calculate the coordinates of the square vertices
x_coord <- lon + c(-1, 1, 1, -1, -1) * half_length
y_coord <- lat + c(-1, -1, 1, 1, -1) * half_length
# Filter points by grid polygon
in_flag <- point.in.polygon(is1$lon, is1$lat, x_coord, y_coord)
filtered_points <- data.frame(cbind(is1$lon, is1$lat,
is1$ht, in_flag))
filtered_points <- filtered_points[filtered_points$in_flag > 0, ]
if (nrow(filtered_points) == 0) {next}
print(paste(lon, lat))
### Step 2 buffer points
dat_sf <- st_as_sf(filtered_points, coords = c("V1", "V2"), crs = 4326)
dat_circles <- st_buffer(dat_sf, dist = 500) # too long
dat_circles_union <- st_union(dat_circles)
#plot(dat_circles_union)
bufferName = paste0("Z:/vclgp/xiongl/HeightComparisonGEDI_IS2_IS1/Out/is1_buffer500m_", i,'_', j, '.gpkg')
print(bufferName)
st_write(dat_circles_union, bufferName, layer = "icesat", delete_layer = TRUE) # overwrites)
}
}
